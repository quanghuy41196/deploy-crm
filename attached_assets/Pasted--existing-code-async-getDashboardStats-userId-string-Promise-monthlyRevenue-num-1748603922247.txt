// ... existing code ...
async getDashboardStats(userId?: string): Promise<{
    monthlyRevenue: number;
    newLeads: number;
    orders: number;
    conversionRate: number;
    pipeline: {
      reception: number;
      consulting: number;
      quoted: number;
      negotiating: number;
      closed: number;
    };
  }> {
    const now = new Date();
    const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    const firstDayOfWeek = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    // Get user permissions
    const user = userId ? await this.getUser(userId) : null;
    const permissions = user ? getPermissionsByRole(user.role) : null;

    // Base query conditions
    let baseConditions = [];
    if (permissions) {
      if (permissions.canViewAllDashboard) {
        // Admin/CEO can view all data
        baseConditions = [];
      } else if (permissions.canViewTeamDashboard) {
        // Leader can view team data
        baseConditions = [eq(orders.teamId, user.teamId)];
      } else {
        // Sale can only view personal data
        baseConditions = [eq(orders.assignedTo, userId)];
      }
    }

    // Monthly revenue from orders
    const revenueQuery = db
      .select({ value: sum(orders.value).as('value') })
      .from(orders)
      .where(and(
        eq(orders.status, "delivered"),
        gte(orders.createdAt, firstDayOfMonth),
        ...baseConditions
      ));

    // New leads this week
    const newLeadsQuery = db
      .select({ count: count().as('count') })
      .from(leads)
      .where(and(
        gte(leads.createdAt, firstDayOfWeek),
        ...baseConditions
      ));

    // Orders this week
    const ordersQuery = db
      .select({ count: count().as('count') })
      .from(orders)
      .where(and(
        gte(orders.createdAt, firstDayOfWeek),
        ...baseConditions
      ));

    // Pipeline counts
    const pipelineQuery = db
      .select({ 
        stage: leads.stage, 
        count: count().as('count')
      })
      .from(leads)
      .where(and(...baseConditions))
      .groupBy(leads.stage);

    // Total leads for conversion rate
    const totalLeadsQuery = db
      .select({ count: count().as('count') })
      .from(leads)
      .where(and(
        gte(leads.createdAt, firstDayOfMonth),
        ...baseConditions
      ));

    // Closed deals for conversion rate
    const closedDealsQuery = db
      .select({ count: count().as('count') })
      .from(leads)
      .where(and(
        eq(leads.stage, "closed"),
        gte(leads.updatedAt, firstDayOfMonth),
        ...baseConditions
      ));

    const [
      revenueResult,
      newLeadsResult,
      ordersResult,
      pipelineResult,
      totalLeadsResult,
      closedDealsResult,
    ] = await Promise.all([
      revenueQuery,
      newLeadsQuery,
      ordersQuery,
      pipelineQuery,
      totalLeadsQuery,
      closedDealsQuery,
    ]);

    const pipeline = {
      reception: 0,
      consulting: 0,
      quoted: 0,
      negotiating: 0,
      closed: 0,
    };

    pipelineResult.forEach((item) => {
      if (item.stage && pipeline.hasOwnProperty(item.stage)) {
        pipeline[item.stage as keyof typeof pipeline] = item.count;
      }
    });

    const totalLeads = totalLeadsResult[0].count;
    const closedDeals = closedDealsResult[0].count;
    const conversionRate = totalLeads > 0 ? (closedDeals / totalLeads) * 100 : 0;

    return {
      monthlyRevenue: Number(revenueResult[0].value) || 0,
      newLeads: newLeadsResult[0].count,
      orders: ordersResult[0].count,
      conversionRate: Math.round(conversionRate * 10) / 10,
      pipeline,
    };
  }
// ... existing code ...